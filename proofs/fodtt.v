(* generated by Ott 0.25 from: fodtt_nl-typing.ott fodtt-typing.ott fodtt-flas_both.ott fodtt-terminals.ott fodtt_nl-syntax.ott fodtt-syntax.ott fodtt-metavar.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.


Definition var := nat. (*r term variable *)
Lemma eq_var: forall (x y : var), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_var : ott_coq_equality.
Definition con := nat. (*r term level constante *)
Lemma eq_con: forall (x y : con), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_con : ott_coq_equality.
Definition tcon := nat. (*r type level constants *)
Lemma eq_tcon: forall (x y : tcon), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_tcon : ott_coq_equality.

Inductive Ty : Set :=  (*r Types *)
 | type_tcon (tcon5:tcon) (*r type constante *)
 | type_pi_elim (Ty5:Ty) (te5:te) (*r application of a type former *)
 | type_pi_intro (var5:var) (Ty5:Ty) (Ty':Ty) (*r type of dependente functions *)
with te : Set :=  (*r Terms *)
 | term_var (var5:var) (*r variables *)
 | term_con (con5:con) (*r term constants *)
 | term_pi_intro (var5:var) (Ty5:Ty) (te5:te) (*r formation of $\Pi$ type *)
 | term_pi_elim (te5:te) (te':te) (*r application *).

Inductive K : Set :=  (*r Kinds *)
 | kind_type : K (*r kind of all types *)
 | kind_pi_intro (var5:var) (Ty5:Ty) (K5:K) (*r kind of dependente functions *).

Definition sgn : Set := list (con*Ty+tcon*K).

Definition ctx : Set := list (var*Ty).

Inductive cdb : Set :=  (*r deBruijn indices for contexts *)
 | cdb_zero : cdb
 | cdb_succ (cdb5:cdb).

Inductive pdb : Set :=  (*r deBruijn indices for pi types *)
 | pdb_zero : pdb
 | pdb_succ (pdb5:pdb).

Inductive nTy : Set :=  (*r Types *)
 | type_nl_tcon (tcon5:tcon) (*r type constante *)
 | type_nl_pi_elim (nTy5:nTy) (nte5:nte) (*r application of a type former *)
 | type_nl_pi_intro (nTy5:nTy) (nTy':nTy) (*r type of dependente functions *)
with nte : Set :=  (*r Terms *)
 | term_nl_cdb (cdb5:cdb) (*r indices left of $\vdash$ (context) *)
 | term_nl_pdb (pdb5:pdb) (*r indices right of $\vdash$ ($\Pi$ and $\Sigma$ types) *)
 | term_nl_con (con5:con) (*r term constants *)
 | term_nl_pi_intro (nTy5:nTy) (nte5:nte) (*r formation of $\Pi$ type *)
 | term_nl_pi_elim (nte5:nte) (nte':nte) (*r application *).

Inductive nK : Set :=  (*r Kinds *)
 | kind_nl_type : nK (*r kind of all types *)
 | kind_nl_pi_intro (nTy5:nTy) (nK5:nK) (*r kind of dependente functions *).

Definition nsgn : Set := list (con*nTy+tcon*nK).

Definition nctx : Set := list (nTy).
Notation sigempty := (@nil (con*Ty+tcon*K)).
Notation ctxempty := (@nil (var*Ty)).

Definition fstSig (e : (con*Ty)+(tcon*K) ) := match e with
    | inl (c, ty) => inl c
    | inr (alpha, k) => inr alpha
  end.

Definition boundCon c T0 S :=
  exists S1, exists S2,
    (S = List.app S1 (List.cons (inl(c,T0)) S2)) /\
    ~In (inl(c)) (List.map (fstSig) S1).

Definition boundTCon alpha T0 S :=
  exists S1, exists S2,
    (S = List.app S1 (List.cons (inr(alpha,T0)) S2)) /\
    ~In (inr(alpha)) (List.map (fstSig) S1).

Definition boundVar x T0 G :=
  exists G1, exists G2,
    (G = List.app G1 (List.cons (x,T0) G2)) /\
    ~In x (List.map (@fst var Ty) G1).

Definition indomCon c S :=
  exists T0,
    boundCon c T0 S.

Definition indomTCon alpha S :=
  exists T0,
    boundCon alpha T0 S.

Definition indomVar x S :=
  exists T0,
    boundVar x T0 S.


(** library functions *)
Fixpoint list_mem A (eq:forall a b:A,{a=b}+{a<>b}) (x:A) (l:list A) {struct l} : bool :=
  match l with
  | nil => false
  | cons h t => if eq h x then true else list_mem A eq x t
end.
Implicit Arguments list_mem.

Fixpoint list_minus A (eq:forall a b:A,{a=b}+{a<>b}) (l1:list A) (l2:list A) {struct l1} : list A :=
  match l1 with
  | nil => nil
  | cons h t => if (list_mem (A:=A) eq h l2) then list_minus A eq t l2 else cons h (list_minus A eq t l2)
end.
Implicit Arguments list_minus.


(** free variables *)
Fixpoint fv_te (m5:te) : list var :=
  match m5 with
  | (term_var var5) => (cons var5 nil)
  | (term_con con5) => nil
  | (term_pi_intro var5 Ty5 te5) => (app (fv_Ty Ty5) (list_minus eq_var (fv_te te5) (cons var5 nil)))
  | (term_pi_elim te5 te') => (app (fv_te te5) (fv_te te'))
end
with fv_Ty (a5:Ty) : list var :=
  match a5 with
  | (type_tcon tcon5) => nil
  | (type_pi_elim Ty5 te5) => (app (fv_Ty Ty5) (fv_te te5))
  | (type_pi_intro var5 Ty5 Ty') => (app (list_minus eq_var (fv_Ty Ty5) (cons var5 nil)) (fv_Ty Ty'))
end.

Fixpoint fv_K (K_6:K) : list var :=
  match K_6 with
  | kind_type => nil
  | (kind_pi_intro var5 Ty5 K5) => (app (fv_Ty Ty5) (list_minus eq_var (fv_K K5) (cons var5 nil)))
end.


(** substitutions *)
Fixpoint subst_te (m5:te) (x5:var) (m_6:te) {struct m_6} : te :=
  match m_6 with
  | (term_var var5) => (if eq_var var5 x5 then m5 else (term_var var5))
  | (term_con con5) => term_con con5
  | (term_pi_intro var5 Ty5 te5) => term_pi_intro var5 (subst_Ty m5 x5 Ty5) (if list_mem eq_var x5 (cons var5 nil) then te5 else (subst_te m5 x5 te5))
  | (term_pi_elim te5 te') => term_pi_elim (subst_te m5 x5 te5) (subst_te m5 x5 te')
end
with subst_Ty (m5:te) (x5:var) (a5:Ty) {struct a5} : Ty :=
  match a5 with
  | (type_tcon tcon5) => type_tcon tcon5
  | (type_pi_elim Ty5 te5) => type_pi_elim (subst_Ty m5 x5 Ty5) (subst_te m5 x5 te5)
  | (type_pi_intro var5 Ty5 Ty') => type_pi_intro var5 (if list_mem eq_var x5 (cons var5 nil) then Ty5 else (subst_Ty m5 x5 Ty5)) (subst_Ty m5 x5 Ty')
end.

Fixpoint subst_K (m5:te) (x5:var) (K_6:K) {struct K_6} : K :=
  match K_6 with
  | kind_type => kind_type 
  | (kind_pi_intro var5 Ty5 K5) => kind_pi_intro var5 (subst_Ty m5 x5 Ty5) (if list_mem eq_var x5 (cons var5 nil) then K5 else (subst_K m5 x5 K5))
end.

(** definitions *)

(* defns Jwellformed *)
Inductive wfsig : sgn -> Prop :=    (* defn wfsig *)
 | sig_empty : 
     wfsig  sigempty 
 | sig_tcon : forall (sgn5:sgn) (alpha:tcon) (K5:K),
     wfsig sgn5 ->
     wfkind sgn5  ctxempty  K5 ->
      (not (indomTCon  alpha   sgn5 ))  ->
     wfsig  (cons (inr( alpha , K5 ))  sgn5 ) 
 | sig_con : forall (sgn5:sgn) (c:con) (A:Ty),
     wfsig sgn5 ->
     wftype sgn5  ctxempty  A kind_type ->
      (not (indomCon  c   sgn5 ))  ->
     wfsig  (cons (inl( c , A ))  sgn5 ) 
with wfctx : sgn -> ctx -> Prop :=    (* defn wfctx *)
 | ctx_empty : forall (sgn5:sgn),
     wfsig sgn5 ->
     wfctx sgn5  ctxempty 
 | ctx_var : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty),
     wfctx sgn5 ctx5 ->
     wftype sgn5 ctx5 A kind_type ->
      (not (indomVar  x   ctx5 ))  ->
     wfctx sgn5  (cons ( x , A )  ctx5 ) 
with wfkind : sgn -> ctx -> K -> Prop :=    (* defn wfkind *)
 | k_type : forall (sgn5:sgn) (ctx5:ctx),
     wfctx sgn5 ctx5 ->
     wfkind sgn5 ctx5 kind_type
 | k_pi_intro : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty) (K5:K),
     wfkind sgn5  (cons ( x , A )  ctx5 )  K5 ->
     wfkind sgn5 ctx5 (kind_pi_intro x A K5)
with wftype : sgn -> ctx -> Ty -> K -> Prop :=    (* defn wftype *)
 | ty_tcon : forall (sgn5:sgn) (ctx5:ctx) (alpha:tcon) (K5:K),
     wfctx sgn5 ctx5 ->
      (boundTCon  alpha   K5   sgn5 )  ->
     wftype sgn5 ctx5 (type_tcon alpha) K5
 | ty_pi_intro : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A B:Ty),
     wftype sgn5  (cons ( x , A )  ctx5 )  B kind_type ->
     wftype sgn5 ctx5 (type_pi_intro x A B) kind_type
 | ty_pi_elim : forall (sgn5:sgn) (ctx5:ctx) (A:Ty) (M:te) (K5:K) (x:var) (B:Ty),
     wftype sgn5 ctx5 A (kind_pi_intro x B K5) ->
     wfterm sgn5 ctx5 M B ->
     wftype sgn5 ctx5 (type_pi_elim A M)  (subst_K  M   x   K5 ) 
with wfterm : sgn -> ctx -> te -> Ty -> Prop :=    (* defn wfterm *)
 | te_con : forall (sgn5:sgn) (ctx5:ctx) (c:con) (A:Ty),
     wfctx sgn5 ctx5 ->
      (boundCon  c   A   sgn5 )  ->
     wfterm sgn5 ctx5 (term_con c) A
 | te_var : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty),
     wfctx sgn5 ctx5 ->
      (boundVar  x   A   ctx5 )  ->
     wfterm sgn5 ctx5 (term_var x) A
 | te_pi_intro : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty) (M:te) (B:Ty),
     wfterm sgn5  (cons ( x , A )  ctx5 )  M B ->
     wfterm sgn5 ctx5 (term_pi_intro x A M) (type_pi_intro x A B)
 | te_pi_elim : forall (sgn5:sgn) (ctx5:ctx) (M N:te) (B:Ty) (x:var) (A:Ty),
     wfterm sgn5 ctx5 M (type_pi_intro x A B) ->
     wfterm sgn5 ctx5 N A ->
     wfterm sgn5 ctx5 (term_pi_elim M N)  ( subst_Ty  N   x   B  ) 
 | te_conv : forall (sgn5:sgn) (ctx5:ctx) (M:te) (A' A:Ty),
     wfterm sgn5 ctx5 M A ->
     wftype sgn5 ctx5 A' kind_type ->
     substaptype sgn5 ctx5 A A' ->
     wfterm sgn5 ctx5 M A'
with substapkind : sgn -> ctx -> K -> K -> Prop :=    (* defn substapkind *)
 | eqK_refl : forall (sgn5:sgn) (ctx5:ctx) (K5:K),
     substapkind sgn5 ctx5 K5 K5
 | eqK_sym : forall (sgn5:sgn) (ctx5:ctx) (K5 K':K),
     substapkind sgn5 ctx5 K' K5 ->
     substapkind sgn5 ctx5 K5 K'
 | eqK_trans : forall (sgn5:sgn) (ctx5:ctx) (K_1 K_3 K_2:K),
     substapkind sgn5 ctx5 K_1 K_2 ->
     substapkind sgn5 ctx5 K_2 K_3 ->
     substapkind sgn5 ctx5 K_1 K_3
 | eqK_1 : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty) (K5:K) (A':Ty) (K':K),
     substaptype sgn5 ctx5 A A' ->
     substapkind sgn5 ctx5 K5 K' ->
     substapkind sgn5 ctx5 (kind_pi_intro x A K5) (kind_pi_intro x A' K')
with substaptype : sgn -> ctx -> Ty -> Ty -> Prop :=    (* defn substaptype *)
 | eqT_refl : forall (sgn5:sgn) (ctx5:ctx) (A:Ty),
     substaptype sgn5 ctx5 A A
 | eqT_sym : forall (sgn5:sgn) (ctx5:ctx) (A A':Ty),
     substaptype sgn5 ctx5 A' A ->
     substaptype sgn5 ctx5 A A'
 | eqT_trans : forall (sgn5:sgn) (ctx5:ctx) (A_1 A_3 A_2:Ty),
     substaptype sgn5 ctx5 A_1 A_2 ->
     substaptype sgn5 ctx5 A_2 A_3 ->
     substaptype sgn5 ctx5 A_1 A_3
 | eqT_1 : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A B A' B':Ty),
     substaptype sgn5 ctx5 A A' ->
     substaptype sgn5 ctx5 B B' ->
     substaptype sgn5 ctx5 (type_pi_intro x A B) (type_pi_intro x A' B')
 | eqT_2 : forall (sgn5:sgn) (ctx5:ctx) (A:Ty) (M:te) (A':Ty) (M':te),
     substaptype sgn5 ctx5 A A' ->
     substapterm sgn5 ctx5 M M' ->
     substaptype sgn5 ctx5 (type_pi_elim A M) (type_pi_elim A' M')
with substapterm : sgn -> ctx -> te -> te -> Prop :=    (* defn substapterm *)
 | eqt_refl : forall (sgn5:sgn) (ctx5:ctx) (M:te),
     substapterm sgn5 ctx5 M M
 | eqt_sym : forall (sgn5:sgn) (ctx5:ctx) (M M':te),
     substapterm sgn5 ctx5 M' M ->
     substapterm sgn5 ctx5 M M'
 | eqt_trans : forall (sgn5:sgn) (ctx5:ctx) (M_1 M_3 M_2:te),
     substapterm sgn5 ctx5 M_1 M_2 ->
     substapterm sgn5 ctx5 M_2 M_3 ->
     substapterm sgn5 ctx5 M_1 M_3
 | eqt_1 : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty) (M N M' N':te),
     substapterm sgn5 ctx5 M M' ->
     substapterm sgn5 ctx5 N N' ->
     substapterm sgn5 ctx5 (term_pi_elim  (term_pi_intro x A M)  N)  ( subst_te  N'   x   M'  ) 
 | eqt_2 : forall (sgn5:sgn) (ctx5:ctx) (M N M' N':te),
     substapterm sgn5 ctx5 M M' ->
     substapterm sgn5 ctx5 N N' ->
     substapterm sgn5 ctx5 (term_pi_elim M N) (term_pi_elim M' N')
 | eqt_3 : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty) (M:te) (A':Ty) (M':te),
     substaptype sgn5 ctx5 A A' ->
     substapterm sgn5 ctx5 M M' ->
     substapterm sgn5 ctx5 (term_pi_intro x A M) (term_pi_intro x A' M').
Notation nsigempty := (@nil (con*nTy+tcon*nK)).
Notation nctxempty := (@nil (nTy)).

Definition fstnSig (e : (con*nTy)+(tcon*nK) ) := match e with
    | inl (c, nty) => inl c
    | inr (beta, nk) => inr beta
  end.


Definition boundnCon c T0 S :=
  exists S1, exists S2,
    (S = List.app S1 (List.cons (inl(c,T0)) S2)) /\
    ~In (inl(c)) (List.map (fstnSig) S1).

Definition boundnTCon alpha T0 S :=
  exists S1, exists S2,
    (S = List.app S1 (List.cons (inr(alpha,T0)) S2)) /\
    ~In (inr(alpha)) (List.map (fstnSig) S1).

(*
Definition boundVar x T0 G :=
  exists G1, exists G2,
    (G = List.app G1 (List.cons (x,T0) G2)) /\
    ~In x (List.map (@fst var Ty) G1).
*)

Definition indomnCon c S :=
  exists T0,
    boundnCon c T0 S.

Definition indomnTCon alpha S :=
  exists T0,
    boundnTCon alpha T0 S.

(*
Definition indomVar x S :=
  exists T0,
    boundVar x T0 S.
*)


(** definitions *)

(** funs PincteTy *)
Fixpoint pincte (x1:nte) : nte:=
  match x1 with
  | (term_nl_cdb cdb_zero) => (term_nl_pdb pdb_zero)
  | (term_nl_cdb (cdb_succ ic)) => (term_nl_cdb ic)
  | (term_nl_pdb ip) => (term_nl_pdb (pdb_succ ip))
  | (term_nl_con c) => (term_nl_con c)
  | (term_nl_pi_intro C P) => (term_nl_pi_intro  (pincTy C )   (pincte P ) )
  | (term_nl_pi_elim Q P) => (term_nl_pi_elim   (pincte Q )     (pincte P )  )
end
with pincTy (x1:nTy) : nTy:=
  match x1 with
  | (type_nl_tcon alpha) => (type_nl_tcon alpha)
  | (type_nl_pi_elim C P) => (type_nl_pi_elim   (pincTy C )     (pincte P )  )
  | (type_nl_pi_intro C D) => (type_nl_pi_intro  (pincTy C )   (pincTy D ) )
end.

(** definitions *)

(** funs PincK *)
Fixpoint pincK (x1:nK) : nK:=
  match x1 with
  | kind_nl_type => kind_nl_type
  | (kind_nl_pi_intro C nK5) => (kind_nl_pi_intro  (pincTy C )   (pincK nK5 ) )
end.

(** definitions *)

(** funs PdecteTy *)
Fixpoint pdecte (x1:nte) : nte:=
  match x1 with
  | (term_nl_cdb ic) => (term_nl_cdb (cdb_succ ic))
  | (term_nl_pdb pdb_zero) => (term_nl_cdb cdb_zero)
  | (term_nl_pdb (pdb_succ ip)) => (term_nl_pdb ip)
  | (term_nl_con c) => (term_nl_con c)
  | (term_nl_pi_intro C P) => (term_nl_pi_intro  (pdecTy C )   (pdecte P ) )
  | (term_nl_pi_elim Q P) => (term_nl_pi_elim   (pdecte Q )     (pdecte P )  )
end
with pdecTy (x1:nTy) : nTy:=
  match x1 with
  | (type_nl_tcon alpha) => (type_nl_tcon alpha)
  | (type_nl_pi_elim C P) => (type_nl_pi_elim   (pdecTy C )     (pdecte P )  )
  | (type_nl_pi_intro C D) => (type_nl_pi_intro  (pdecTy C )   (pdecTy D ) )
end.

(** definitions *)

(** funs PdecK *)
Fixpoint pdecK (x1:nK) : nK:=
  match x1 with
  | kind_nl_type => kind_nl_type
  | (kind_nl_pi_intro C nK5) => (kind_nl_pi_intro  (pdecTy C )   (pdecK nK5 ) )
end.

(** definitions *)

(** funs Psubst *)
Fixpoint psubste (x1:nte) (x2:nte) : nte:=
  match x1,x2 with
  | (term_nl_cdb ic) , Q => (term_nl_cdb ic)
  | (term_nl_pdb pdb_zero) , Q => Q
  | (term_nl_pdb (pdb_succ ip)) , Q => (term_nl_pdb ip)
  | (term_nl_con c) , Q => (term_nl_con c)
  | (term_nl_pi_intro C P) , Q => (term_nl_pi_intro  (psubsTy C Q )   (psubste P Q ) )
  | (term_nl_pi_elim P1 P2) , Q => (term_nl_pi_elim   (psubste P1 Q )     (psubste P2 Q )  )
end
with psubsTy (x1:nTy) (x2:nte) : nTy:=
  match x1,x2 with
  | (type_nl_tcon alpha) , Q => (type_nl_tcon alpha)
  | (type_nl_pi_elim C P) , Q => (type_nl_pi_elim   (psubsTy C Q )     (psubste P Q )  )
  | (type_nl_pi_intro C D) , Q => (type_nl_pi_intro  (psubsTy C Q )   (psubsTy D Q ) )
end.

(** definitions *)

(** funs PsubsK *)
Fixpoint psubsK (x1:nK) (x2:nte) : nK:=
  match x1,x2 with
  | kind_nl_type , Q => kind_nl_type
  | (kind_nl_pi_intro C nK5) , Q => (kind_nl_pi_intro  (psubsTy C Q )   (psubsK nK5 Q ) )
end.

(** definitions *)

(* defns Jwfnl *)
Inductive wfsig_nl : nsgn -> Prop :=    (* defn wfsig_nl *)
 | sig_nl_empty : 
     wfsig_nl  nsigempty 
 | sig_nl_tcon : forall (nsgn5:nsgn) (alpha:tcon) (nK5:nK),
     wfsig_nl nsgn5 ->
     wfkind_nl nsgn5  nctxempty  nK5 ->
      (not (indomnTCon  alpha   nsgn5 ))  ->
     wfsig_nl  (cons (inr( alpha , nK5 ))  nsgn5 ) 
 | sig_nl_con : forall (nsgn5:nsgn) (c:con) (C:nTy),
     wfsig_nl nsgn5 ->
     wftype_nl nsgn5  nctxempty  C kind_nl_type ->
      (not (indomnCon  c   nsgn5 ))  ->
     wfsig_nl  (cons (inl( c , C ))  nsgn5 ) 
with wfctx_nl : nsgn -> nctx -> Prop :=    (* defn wfctx_nl *)
 | ctx_nl_empty : forall (nsgn5:nsgn),
     wfsig_nl nsgn5 ->
     wfctx_nl nsgn5  nctxempty 
 | ctx_nl_var : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy),
     wfctx_nl nsgn5 nctx5 ->
     wftype_nl nsgn5 nctx5 C kind_nl_type ->
     wfctx_nl nsgn5  (cons  C   nctx5 ) 
with wfkind_nl : nsgn -> nctx -> nK -> Prop :=    (* defn wfkind_nl *)
 | k_nl_type : forall (nsgn5:nsgn) (nctx5:nctx),
     wfctx_nl nsgn5 nctx5 ->
     wfkind_nl nsgn5 nctx5 kind_nl_type
 | k_nl_pi_intro : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (nK5:nK),
     wfkind_nl nsgn5  (cons  C   nctx5 )  nK5 ->
     wfkind_nl nsgn5 nctx5 (kind_nl_pi_intro C nK5)
with wftype_nl : nsgn -> nctx -> nTy -> nK -> Prop :=    (* defn wftype_nl *)
 | ty_nl_tcon : forall (nsgn5:nsgn) (nctx5:nctx) (alpha:tcon) (nK5:nK),
     wfctx_nl nsgn5 nctx5 ->
      (boundnTCon  alpha   nK5   nsgn5 )  ->
     wftype_nl nsgn5 nctx5 (type_nl_tcon alpha) nK5
 | ty_nl_pi_intro : forall (nsgn5:nsgn) (nctx5:nctx) (C D:nTy),
     wftype_nl nsgn5  (cons  C   nctx5 )  D kind_nl_type ->
     wftype_nl nsgn5 nctx5 (type_nl_pi_intro C  (pincTy D ) ) kind_nl_type
 | ty_nl_pi_elim : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (Q:nte) (nK5:nK) (D:nTy),
     wftype_nl nsgn5 nctx5 C (kind_nl_pi_intro D nK5) ->
     wfterm_nl nsgn5 nctx5 Q D ->
     wftype_nl nsgn5 nctx5 (type_nl_pi_elim C Q)  (psubsK nK5 Q ) 
with wfterm_nl : nsgn -> nctx -> nte -> nTy -> Prop :=    (* defn wfterm_nl *)
 | te_nl_con : forall (nsgn5:nsgn) (nctx5:nctx) (c:con) (C:nTy),
     wfctx_nl nsgn5 nctx5 ->
      (boundnCon  c   C   nsgn5 )  ->
     wfterm_nl nsgn5 nctx5 (term_nl_con c) C
 | te_nl_var_z : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy),
     wfctx_nl nsgn5  (cons  C   nctx5 )  ->
     wfterm_nl nsgn5  (cons  C   nctx5 )  (term_nl_cdb cdb_zero) C
 | te_nl_var : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (ic:cdb) (D:nTy),
     wfctx_nl nsgn5  (cons  C   nctx5 )  ->
     wfterm_nl nsgn5 nctx5 (term_nl_cdb ic) D ->
     wfterm_nl nsgn5  (cons  C   nctx5 )  (term_nl_cdb (cdb_succ ic)) D
 | te_nl_pi_intro : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (Q:nte) (D:nTy),
     wfterm_nl nsgn5  (cons  C   nctx5 )  Q D ->
     wfterm_nl nsgn5 nctx5 (term_nl_pi_intro C  (pincte Q ) ) (type_nl_pi_intro C  (pincTy D ) )
 | te_nl_pi_elim : forall (nsgn5:nsgn) (nctx5:nctx) (Q P:nte) (D C:nTy),
     wfterm_nl nsgn5 nctx5 Q (type_nl_pi_intro C D) ->
     wfterm_nl nsgn5 nctx5 P C ->
     wfterm_nl nsgn5 nctx5 (term_nl_pi_elim Q P)  (psubsTy D P ) 
 | te_nl_conv : forall (nsgn5:nsgn) (nctx5:nctx) (Q:nte) (C' C:nTy),
     wfterm_nl nsgn5 nctx5 Q C ->
     wftype_nl nsgn5 nctx5 C' kind_nl_type ->
     substaptype_nl nsgn5 nctx5 C C' kind_nl_type ->
     wfterm_nl nsgn5 nctx5 Q C'
with substaptype_nl : nsgn -> nctx -> nTy -> nTy -> nK -> Prop :=    (* defn substaptype_nl *)
 | eqT_nl_refl : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (nK5:nK),
     wftype_nl nsgn5 nctx5 C nK5 ->
     substaptype_nl nsgn5 nctx5 C C nK5
 | eqT_nl_sym : forall (nsgn5:nsgn) (nctx5:nctx) (C C':nTy) (nK5:nK),
     substaptype_nl nsgn5 nctx5 C' C nK5 ->
     substaptype_nl nsgn5 nctx5 C C' nK5
 | eqT_nl_trans : forall (nsgn5:nsgn) (nctx5:nctx) (C_1 C_3:nTy) (nK5:nK) (C_2:nTy),
     substaptype_nl nsgn5 nctx5 C_1 C_2 nK5 ->
     substaptype_nl nsgn5 nctx5 C_2 C_3 nK5 ->
     substaptype_nl nsgn5 nctx5 C_1 C_3 nK5
 | eqT_nl_1 : forall (nsgn5:nsgn) (nctx5:nctx) (C D C' D':nTy),
     substaptype_nl nsgn5 nctx5 C C' kind_nl_type ->
     substaptype_nl nsgn5 nctx5 D D' kind_nl_type ->
     substaptype_nl nsgn5 nctx5 (type_nl_pi_intro C D) (type_nl_pi_intro C' D') kind_nl_type
 | eqT_nl_2 : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (Q:nte) (C':nTy) (Q':nte),
     substaptype_nl nsgn5 nctx5 C C' kind_nl_type ->
     substapterm_nl nsgn5 nctx5 Q Q' C ->
     substaptype_nl nsgn5 nctx5 (type_nl_pi_elim C Q) (type_nl_pi_elim C' Q') kind_nl_type
with substapterm_nl : nsgn -> nctx -> nte -> nte -> nTy -> Prop :=    (* defn substapterm_nl *)
 | eqt_nl_refl : forall (nsgn5:nsgn) (nctx5:nctx) (Q:nte) (C:nTy),
     wfterm_nl nsgn5 nctx5 Q C ->
     substapterm_nl nsgn5 nctx5 Q Q C
 | eqt_nl_sym : forall (nsgn5:nsgn) (nctx5:nctx) (Q Q':nte) (C:nTy),
     substapterm_nl nsgn5 nctx5 Q' Q C ->
     substapterm_nl nsgn5 nctx5 Q Q' C
 | eqt_nl_trans : forall (nsgn5:nsgn) (nctx5:nctx) (Q_1 Q_3:nte) (C:nTy) (Q_2:nte),
     substapterm_nl nsgn5 nctx5 Q_1 Q_2 C ->
     substapterm_nl nsgn5 nctx5 Q_2 Q_3 C ->
     substapterm_nl nsgn5 nctx5 Q_1 Q_3 C
 | eqt_nl_1 : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (Q P Q' P':nte) (D:nTy),
     substapterm_nl nsgn5 nctx5 Q Q' C ->
     substapterm_nl nsgn5 nctx5 P P' D ->
     substapterm_nl nsgn5 nctx5 (term_nl_pi_elim  (term_nl_pi_intro C Q)  P)  (psubste Q' P' )   (psubsTy C P' ) 
 | eqt_nl_2 : forall (nsgn5:nsgn) (nctx5:nctx) (Q P Q' P':nte) (C D:nTy),
     substapterm_nl nsgn5 nctx5 Q Q' (type_nl_pi_intro C D) ->
     substapterm_nl nsgn5 nctx5 P P' C ->
     substapterm_nl nsgn5 nctx5 (term_nl_pi_elim Q P) (term_nl_pi_elim Q' P')  (psubsTy C P ) 
 | eqt_nl_3 : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (Q:nte) (C':nTy) (Q':nte) (D:nTy),
     substaptype_nl nsgn5 nctx5 C C' kind_nl_type ->
     substapterm_nl nsgn5 nctx5 Q Q' D ->
     substapterm_nl nsgn5 nctx5 (term_nl_pi_intro C Q) (term_nl_pi_intro C' Q') (type_nl_pi_intro C D).
(** definitions *)

(* defns Jtrans_teTy *)
Inductive transte : te -> ctx -> nte -> Prop :=    (* defn transte *)
 | transte_cdb_zero : forall (x:var) (ctx5:ctx) (A:Ty),
     transte (term_var x)  (cons ( x , A )  ctx5 )  (term_nl_cdb cdb_zero)
 | transte_cdb_succ : forall (y:var) (ctx5:ctx) (x:var) (A:Ty) (cdb5:cdb),
     transte (term_var y) ctx5 (term_nl_cdb cdb5) ->
     transte (term_var y)  (cons ( x , A )  ctx5 )  (term_nl_cdb (cdb_succ cdb5))
 | transte_con : forall (c:con) (ctx5:ctx),
     transte (term_con c) ctx5 (term_nl_con c)
 | transte_pi_intro : forall (x:var) (A:Ty) (M:te) (ctx5:ctx) (C:nTy) (P:nte),
     transTy A ctx5 C ->
     transte M  (cons ( x , A )  ctx5 )  P ->
     transte (term_pi_intro x A M) ctx5 (term_nl_pi_intro C  (pdecte P ) )
 | transte_pi_elim : forall (M N:te) (ctx5:ctx) (P Q:nte),
     transte M ctx5 P ->
     transte N ctx5 Q ->
     transte (term_pi_elim M N) ctx5 (term_nl_pi_elim P Q)
with transTy : Ty -> ctx -> nTy -> Prop :=    (* defn transTy *)
 | transty_tcon : forall (alpha:tcon) (ctx5:ctx),
     transTy (type_tcon alpha) ctx5 (type_nl_tcon alpha)
 | transty_pi_intro : forall (x:var) (A B:Ty) (ctx5:ctx) (C D:nTy),
     transTy A ctx5 C ->
     transTy B  (cons ( x , A )  ctx5 )  D ->
     transTy (type_pi_intro x A B) ctx5 (type_nl_pi_intro C  (pdecTy D ) )
 | transty_pi_elim : forall (A:Ty) (M:te) (ctx5:ctx) (C:nTy) (P:nte),
     transTy A ctx5 C ->
     transte M ctx5 P ->
     transTy (type_pi_elim A M) ctx5 (type_nl_pi_elim C P).
(** definitions *)

(* defns Jtrans_ctx *)
Inductive transctx : ctx -> nctx -> Prop :=    (* defn transctx *)
 | transctx_empty : 
     transctx  ctxempty   nctxempty 
 | transctx_var : forall (ctx5:ctx) (x:var) (A:Ty) (nctx5:nctx) (C:nTy),
     transctx ctx5 nctx5 ->
     transTy A ctx5 C ->
     transctx  (cons ( x , A )  ctx5 )   (cons  C   nctx5 ) .


