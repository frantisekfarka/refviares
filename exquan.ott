embed {{ tex-preamble \DeclareMathOperator{\dom}{dom} }}

metavar var {{ tex \mathcal{V} }}, x, y ::= {{ com  term variable }} 
    {{ coq nat}} {{ coq-equality }}
    {{ ocaml string }} {{ lex alphanum}} {{ ocamllex VarAlphanum }}
    {{ tex \mathit{[[var]]} }} 

metavar con {{tex \mathcal{C} }}, c ::=   {{ com  term level constante }} 
    {{ coq nat}} {{ coq-equality }}
    {{ ocaml string }} {{ lex alphanum}} {{ ocamllex ConAlphanum }}
    {{ tex \mathit{[[con]]} }}

metavar tcon {{ tex \mathcal{B} }}, alpha {{ tex \alpha}}, beta {{ tex \beta }} ::=   {{ com  type level constants}} 
    {{ coq nat}} {{ coq-equality }}
    {{ ocaml string }} {{ lex alphanum}} {{ ocamllex TConAlphanum }}
    {{ tex \mathit{[[tcon]]} }}

grammar
K :: 'kind_' ::= {{ com Kinds }}
  | typeK              ::   :: type                          {{ com kind of all types }} 
  | Pi var : Ty . K    ::   :: pi_intro (+ bind var in K +)  {{ com kind of dependente functions }}
  | K [ te / var ]     :: M :: subst                         {{ com substitution }}
     {{ coq (tsubst_K [[te]] [[var]] [[K]]) }}
     {{ ocaml int }}
     {{ tex [[K]] [ [[te]] / [[var]] ] }} 

%% we include 'a' since its used to generate ocaml variables
%% hence we need lowecase
Ty, a , A, B :: 'type_' ::= {{ com Types }}
  | tcon               ::   :: tcon                           {{ com type constante }}
  | Ty te              ::   :: pi_elim                        {{ com application of a type former }}
  | Pi var : Ty . Ty'  ::   :: pi_intro (+ bind var in Ty +)  {{ com type of dependente functions }}
  | Ty [ te / var ]    :: M :: subst                          {{ com substitution }}
     {{ coq ( tsubst_Ty [[te]] [[var]] [[Ty]] ) }}
     {{ ocaml int }}
     {{ tex [[Ty]] [ [[te]] / [[var]] ] }}

%% we include 'm' since its used to generate ocaml variables
%% hence we need lowecase
te, m , M, N :: 'term_' ::= {{ com Terms }}
  | var                ::   :: var                           {{ com variables }} 
  | con                ::   :: con                           {{ com term constants }} 
  | \ var : Ty . te    ::   :: pi_intro (+ bind var in te +) {{ com formation of $\Pi$ type }}
  | te te'             ::   :: pi_elim                       {{ com application }}
  | ( te )             :: S :: paren                        
     {{ coq [[te]] }}
     {{ ocaml te }}
  | te [ te' / var ]   :: M :: subst                         {{ com substitution of term}}
     {{ coq ( tsubst_te [[te']] [[var]] [[te]] ) }}
     {{ ocaml int }}
     {{ tex [[te]] [ [[te']] / [[var]] ] }}

sgn {{ tex \mathcal{S} }} :: 'signature_' ::= {{ com signature }}
    {{ coq list (con*Ty+tcon*K) }}
%    {{ ocaml ((con * ty , tcon*k) sgn_el_type)  list }}
  | sigempty     ::   :: empty             {{ com empty signature }}
     {{ coq sigempty }}
  | sgn , con : Ty  ::   :: con
     {{ coq (cons (inl([[con]],[[Ty]])) [[sgn]]) }}
  | sgn , tcon : K  ::   :: sigtcon
     {{ coq (cons (inr([[tcon]],[[K]])) [[sgn]]) }}

ctx {{ tex \Gamma }} :: 'context_' ::= {{ com contexte }}
    {{ coq list (var*Ty) }}
  | ctxempty    ::   :: ctxempty              {{ com empty contexte }}
     {{ coq ctxempty }}
  | ctx , var : Ty  ::   :: ctxvar
     {{ coq (cons ([[var]],[[Ty]]) [[ctx]]) }}

terminals :: 'terminals_' ::=
  | typeK        ::   :: type     {{ tex \text{type} }}
  | kindS        ::   :: kind     {{ tex \text{kind} }}
  | \            ::   :: lambda   {{ tex \lambda }}
  | Pi           ::   :: pi       {{ tex \Pi }}
  | sigempty     ::   :: sigempty {{ tex \cdot}}
  | ctxempty     ::   :: ctxempty {{ tex \cdot}}

formula :: formula_ ::=          
  | judgement               :: :: judgement
  | c notin dom ( sgn )     :: :: cnotinsig 
     {{ coq (not (indomCon [[c]] [[sgn]])) }}
     {{ tex [[c]] \not\in \dom([[sgn]]) }}
  | alpha notin dom ( sgn ) :: :: bnotinsig  
     {{ coq (not (indomTCon [[alpha]] [[sgn]])) }}
     {{ tex [[alpha]] \not\in \dom([[sgn]]) }}
  | x notin dom ( ctx )     :: :: xnotinctx
     {{ coq (not (indomVar [[x]] [[ctx]])) }}
     {{ tex [[x]] \not\in \dom([[ctx]]) }}
  | c : A in sgn            :: :: cinsig
     {{ coq (boundCon [[c]] [[A]] [[sgn]]) }}
     {{ tex [[c]] : [[A]] \in [[sgn]] }}
  | alpha : K in sgn        :: :: binsig
     {{ coq (boundTCon [[alpha]] [[K]] [[sgn]]) }}
     {{ tex [[alpha]] : [[K]] \in [[sgn]] }}
  | x : A in ctx            :: :: xinctx
     {{ coq (boundVar [[x]] [[A]] [[ctx]]) }}
     {{ tex [[x]] : [[A]] \in [[ctx]] }}

embed
{{ coq
Notation sigempty := (@nil (con*Ty+tcon*K)).
Notation ctxempty := (@nil (var*Ty)).

Definition fstSig (e : (con*Ty)+(tcon*K) ) := match e with
    | inl (c, ty) => inl c
    | inr (alpha, k) => inr alpha
  end.

Definition boundCon c T0 S :=
  exists S1, exists S2,
    (S = List.app S1 (List.cons (inl(c,T0)) S2)) /\
    ~In (inl(c)) (List.map (fstSig) S1).

Definition boundTCon alpha T0 S :=
  exists S1, exists S2,
    (S = List.app S1 (List.cons (inr(alpha,T0)) S2)) /\
    ~In (inr(alpha)) (List.map (fstSig) S1).

Definition boundVar x T0 G :=
  exists G1, exists G2,
    (G = List.app G1 (List.cons (x,T0) G2)) /\
    ~In x (List.map (@fst var Ty) G1).

Definition indomCon c S :=
  exists T0,
    boundCon c T0 S.

Definition indomTCon alpha S :=
  exists T0,
    boundCon alpha T0 S.

Definition indomVar x S :=
  exists T0,
    boundVar x T0 S.

}}
embed
{{ ocaml 
type ('a, 'b) sgn_el_type = Inl of 'a | Inr of 'b
}}


subrules

freevars
% due to recursive definition of Ty and K the fv_Ty and fk_K are also generated
%  Ty x :: tyfv
  te x :: fv

substitutions
%  single K x :: tsubst
%  single Ty x :: tsubst
  single te x :: subst

defns
Jwellformed :: '' ::=


  defn
  |-sig sgn :: ::wfsig::'sig_' {{ tex \vdash [[sgn]] \text{ sig} }} by

    ---------------  :: empty
    |-sig sigempty

    |-sig sgn
    sgn ; ctxempty |- K : kindS
    alpha notin dom(sgn)
    -------------------------- :: tcon
    |-sig sgn,alpha:K

    |-sig sgn
    sgn ; ctxempty |- A : typeK
    c notin dom(sgn) 
    -------------------------- :: con
    |-sig sgn,c:A

  defn
  sgn |-ctx ctx :: ::wfctx::'ctx_' {{tex [[sgn]] \vdash [[ctx]] \text{ ctx} }} by
   
    |-sig sgn
    --------------------  :: empty
    sgn |-ctx ctxempty

    sgn |-ctx ctx
    sgn ; ctx |- A : typeK
    x notin dom(ctx) 
    -------------------------- :: var
    sgn |-ctx ctx,x:A

  defn
  sgn ; ctx |- K : kindS :: ::wfkind::'k_' {{tex [[sgn]] ; [[ctx]] \vdash [[K]] : [[kindS]]}} by

    sgn |-ctx ctx
    -----------------------------  :: type
    sgn ; ctx |- typeK : kindS

    sgn ; ctx,x:A |- K : kindS
    ----------------------------- :: pi_intro
    sgn ; ctx |- Pi x:A.K : kindS

  defn
  sgn ; ctx |- A : K  :: ::wftype::'ty_' {{tex [[sgn]] ; [[ctx]] \vdash [[A]] : [[K]]}} by

    sgn |-ctx ctx
    alpha : K in sgn
    ------------------  :: tcon
    sgn ; ctx |- alpha : K


    sgn ; ctx,x:A |- B : typeK
    ----------------------------------------- :: pi_intro
    sgn ; ctx |- Pi x : A . B : typeK 

    sgn ; ctx |- A : Pi x : B . K
    sgn ; ctx |- M : B
    ----------------------------------------- :: pi_elim
    sgn ; ctx |- A M : K [ M / x ] 

  defn
  sgn ; ctx |- M : A  :: ::wfterm::'te_' {{tex [[sgn]] ; [[ctx]] \vdash [[M]] : [[A]]}} by

    sgn |-ctx ctx
    c : A in sgn
    ----------------------  :: con
    sgn ; ctx |- c : A

    sgn |-ctx ctx
    x : A in ctx
    ----------------------  :: var
    sgn ; ctx |- x : A

    sgn ; ctx,x:A |- M : B 
    ---------------------------------- :: pi_intro
    sgn ; ctx |- \x:A.M : Pi x : A . B 

    sgn ; ctx |- M : Pi x : A . B 
    sgn ; ctx |- N : A
    ------------------------------ :: pi_elim
    sgn ; ctx |- M N : B [ N / x ]

    sgn ; ctx |- M : A
    sgn ; ctx |- A' : typeK
    sgn ; ctx |- A is A' 
    ------------------------------ :: conv
    sgn ; ctx |- M : A' 

  defn 
  sgn ; ctx |- K is K' ::  :: substapkind :: 'eqK_' {{tex [[sgn]] ; [[ctx]] \vdash [[K]] \equiv [[K']] }} by

    --------------------------- :: refl
    sgn ; ctx |- K is K 

    sgn ; ctx |- K' is K 
    ---------------------------- :: sym
    sgn ; ctx |- K is K' 

    sgn ; ctx |- K_1 is K_2
    sgn ; ctx |- K_2 is K_3
    ------------------------------- :: trans
    sgn ; ctx |- K_1 is K_3

    sgn ; ctx |- A is A' 
    sgn ; ctx |- K is K' 
    ------------------------------------ :: 1
    sgn ; ctx |- Pi x:A.K is Pi x:A'.K' 

  defn 
  sgn ; ctx |- A is A' ::  :: substaptype :: 'eqT_' {{ tex [[sgn]] ; [[ctx]] \vdash [[A]] \equiv [[A']] }} by

    %sgn ; ctx |- A 
    --------------------------- :: refl
    sgn ; ctx |- A is A 

    sgn ; ctx |- A' is A 
    ---------------------------- :: sym
    sgn ; ctx |- A is A' 

    sgn ; ctx |- A_1 is A_2 
    sgn ; ctx |- A_2 is A_3 
    ------------------------------- :: trans
    sgn ; ctx |- A_1 is A_3 

    sgn ; ctx |- A is A' 
    sgn ; ctx |- B is B' 
    ------------------------------------ :: 1
    sgn ; ctx |- Pi x:A.B is Pi x:A'.B' 

    sgn ; ctx |- A is A' 
    sgn ; ctx |- M is M' 
    ------------------------------------ :: 2
    sgn ; ctx |- A M is A' M' 

  defn 
  sgn ; ctx |- M is M' ::  :: substapterm :: 'eqt_' {{ tex [[sgn]] ; [[ctx]] \vdash [[M]] \equiv [[M']] }} by

    ----------------------- :: refl
    sgn ; ctx |- M is M 

    sgn ; ctx |- M' is M 
    ------------------------ :: sym
    sgn ; ctx |- M is M' 

    sgn ; ctx |- M_1 is M_2 
    sgn ; ctx |- M_2 is M_3 
    --------------------------- :: trans
    sgn ; ctx |- M_1 is M_3 

    sgn ; ctx |- M is M' 
    sgn ; ctx |- N is N' 
    --------------------------------------- :: 1
    sgn ; ctx |- (\x:A.M)N is M' [ N' / x ] 

    sgn ; ctx |- M is M' 
    sgn ; ctx |- N is N' 
    --------------------------------------- :: 2
    sgn ; ctx |- M N is M' N' 

    sgn ; ctx |- A is A' 
    sgn ; ctx |- M is M' 
    ------------------------------------------ :: 3
    sgn ; ctx |- \x:A.M is \x:A'.M' 



