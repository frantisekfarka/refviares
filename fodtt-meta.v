(* generated by Ott 0.25 from: fodtt_nl-typing.ott fodtt-typing.ott fodtt-flas_both.ott fodtt-terminals.ott fodtt_nl-syntax.ott fodtt-syntax.ott fodtt-metavar.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.


Definition var := nat. (*r term variable *)
Lemma eq_var: forall (x y : var), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_var : ott_coq_equality.
Definition con := nat. (*r term level constante *)
Lemma eq_con: forall (x y : con), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_con : ott_coq_equality.
Definition tcon := nat. (*r type level constants *)
Lemma eq_tcon: forall (x y : tcon), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_tcon : ott_coq_equality.

Inductive Ty : Set :=  (*r Types *)
 | type_tcon (tcon5:tcon) (*r type constante *)
 | type_pi_elim (Ty5:Ty) (te5:te) (*r application of a type former *)
 | type_pi_intro (var5:var) (Ty5:Ty) (Ty':Ty) (*r type of dependente functions *)
with te : Set :=  (*r Terms *)
 | term_var (var5:var) (*r variables *)
 | term_con (con5:con) (*r term constants *)
 | term_pi_intro (var5:var) (Ty5:Ty) (te5:te) (*r formation of $\Pi$ type *)
 | term_pi_elim (te5:te) (te':te) (*r application *).

Inductive K : Set :=  (*r Kinds *)
 | kind_type : K (*r kind of all types *)
 | kind_pi_intro (var5:var) (Ty5:Ty) (K5:K) (*r kind of dependente functions *).

Definition sgn : Set := list (con*Ty+tcon*K).

Definition ctx : Set := list (var*Ty).

Inductive cdb : Set :=  (*r deBruijn indices for contexts *)
 | cdb_zero : cdb
 | cdb_succ (cdb5:cdb).

Inductive pdb : Set :=  (*r deBruijn indices for pi types *)
 | pdb_zero : pdb
 | pdb_succ (pdb5:pdb).

Inductive nTy : Set :=  (*r Types *)
 | type_nl_tcon (tcon5:tcon) (*r type constante *)
 | type_nl_pi_elim (nTy5:nTy) (nte5:nte) (*r application of a type former *)
 | type_nl_pi_intro (nTy5:nTy) (nTy':nTy) (*r type of dependente functions *)
with nte : Set :=  (*r Terms *)
 | term_nl_cdb (cdb5:cdb) (*r indices left of $\vdash$ (context) *)
 | term_nl_pdb (pdb5:pdb) (*r indices right of $\vdash$ ($\Pi$ and $\Sigma$ types) *)
 | term_nl_con (con5:con) (*r term constants *)
 | term_nl_pi_intro (nTy5:nTy) (nte5:nte) (*r formation of $\Pi$ type *)
 | term_nl_pi_elim (nte5:nte) (nte':nte) (*r application *).

Inductive nK : Set :=  (*r Kinds *)
 | kind_nl_type : nK (*r kind of all types *)
 | kind_nl_pi_intro (nTy5:nTy) (nK5:nK) (*r kind of dependente functions *).

Definition nsgn : Set := list (con*nTy+tcon*nK).

Definition nctx : Set := list (nTy).
Notation sigempty := (@nil (con*Ty+tcon*K)).
Notation ctxempty := (@nil (var*Ty)).

Definition fstSig (e : (con*Ty)+(tcon*K) ) := match e with
    | inl (c, ty) => inl c
    | inr (alpha, k) => inr alpha
  end.

Definition boundCon c T0 S :=
  exists S1, exists S2,
    (S = List.app S1 (List.cons (inl(c,T0)) S2)) /\
    ~In (inl(c)) (List.map (fstSig) S1).

Definition boundTCon alpha T0 S :=
  exists S1, exists S2,
    (S = List.app S1 (List.cons (inr(alpha,T0)) S2)) /\
    ~In (inr(alpha)) (List.map (fstSig) S1).

Definition boundVar x T0 G :=
  exists G1, exists G2,
    (G = List.app G1 (List.cons (x,T0) G2)) /\
    ~In x (List.map (@fst var Ty) G1).

Definition indomCon c S :=
  exists T0,
    boundCon c T0 S.

Definition indomTCon alpha S :=
  exists T0,
    boundCon alpha T0 S.

Definition indomVar x S :=
  exists T0,
    boundVar x T0 S.


(** library functions *)
Fixpoint list_mem A (eq:forall a b:A,{a=b}+{a<>b}) (x:A) (l:list A) {struct l} : bool :=
  match l with
  | nil => false
  | cons h t => if eq h x then true else list_mem A eq x t
end.
Implicit Arguments list_mem.

Fixpoint list_minus A (eq:forall a b:A,{a=b}+{a<>b}) (l1:list A) (l2:list A) {struct l1} : list A :=
  match l1 with
  | nil => nil
  | cons h t => if (list_mem (A:=A) eq h l2) then list_minus A eq t l2 else cons h (list_minus A eq t l2)
end.
Implicit Arguments list_minus.


(** free variables *)
Fixpoint fv_te (m5:te) : list var :=
  match m5 with
  | (term_var var5) => (cons var5 nil)
  | (term_con con5) => nil
  | (term_pi_intro var5 Ty5 te5) => (app (fv_Ty Ty5) (list_minus eq_var (fv_te te5) (cons var5 nil)))
  | (term_pi_elim te5 te') => (app (fv_te te5) (fv_te te'))
end
with fv_Ty (a5:Ty) : list var :=
  match a5 with
  | (type_tcon tcon5) => nil
  | (type_pi_elim Ty5 te5) => (app (fv_Ty Ty5) (fv_te te5))
  | (type_pi_intro var5 Ty5 Ty') => (app (list_minus eq_var (fv_Ty Ty5) (cons var5 nil)) (fv_Ty Ty'))
end.

Fixpoint fv_K (K_6:K) : list var :=
  match K_6 with
  | kind_type => nil
  | (kind_pi_intro var5 Ty5 K5) => (app (fv_Ty Ty5) (list_minus eq_var (fv_K K5) (cons var5 nil)))
end.


(** substitutions *)
Fixpoint subst_te (m5:te) (x5:var) (m_6:te) {struct m_6} : te :=
  match m_6 with
  | (term_var var5) => (if eq_var var5 x5 then m5 else (term_var var5))
  | (term_con con5) => term_con con5
  | (term_pi_intro var5 Ty5 te5) => term_pi_intro var5 (subst_Ty m5 x5 Ty5) (if list_mem eq_var x5 (cons var5 nil) then te5 else (subst_te m5 x5 te5))
  | (term_pi_elim te5 te') => term_pi_elim (subst_te m5 x5 te5) (subst_te m5 x5 te')
end
with subst_Ty (m5:te) (x5:var) (a5:Ty) {struct a5} : Ty :=
  match a5 with
  | (type_tcon tcon5) => type_tcon tcon5
  | (type_pi_elim Ty5 te5) => type_pi_elim (subst_Ty m5 x5 Ty5) (subst_te m5 x5 te5)
  | (type_pi_intro var5 Ty5 Ty') => type_pi_intro var5 (if list_mem eq_var x5 (cons var5 nil) then Ty5 else (subst_Ty m5 x5 Ty5)) (subst_Ty m5 x5 Ty')
end.

Fixpoint subst_K (m5:te) (x5:var) (K_6:K) {struct K_6} : K :=
  match K_6 with
  | kind_type => kind_type 
  | (kind_pi_intro var5 Ty5 K5) => kind_pi_intro var5 (subst_Ty m5 x5 Ty5) (if list_mem eq_var x5 (cons var5 nil) then K5 else (subst_K m5 x5 K5))
end.

(** definitions *)

(* defns Jwellformed *)
Inductive wfsig : sgn -> Prop :=    (* defn wfsig *)
 | sig_empty : 
     wfsig  sigempty 
 | sig_tcon : forall (sgn5:sgn) (alpha:tcon) (K5:K),
     wfsig sgn5 ->
     wfkind sgn5  ctxempty  K5 ->
      (not (indomTCon  alpha   sgn5 ))  ->
     wfsig  (cons (inr( alpha , K5 ))  sgn5 ) 
 | sig_con : forall (sgn5:sgn) (c:con) (A:Ty),
     wfsig sgn5 ->
     wftype sgn5  ctxempty  A kind_type ->
      (not (indomCon  c   sgn5 ))  ->
     wfsig  (cons (inl( c , A ))  sgn5 ) 
with wfctx : sgn -> ctx -> Prop :=    (* defn wfctx *)
 | ctx_empty : forall (sgn5:sgn),
     wfsig sgn5 ->
     wfctx sgn5  ctxempty 
 | ctx_var : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty),
     wfctx sgn5 ctx5 ->
     wftype sgn5 ctx5 A kind_type ->
      (not (indomVar  x   ctx5 ))  ->
     wfctx sgn5  (cons ( x , A )  ctx5 ) 
with wfkind : sgn -> ctx -> K -> Prop :=    (* defn wfkind *)
 | k_type : forall (sgn5:sgn) (ctx5:ctx),
     wfctx sgn5 ctx5 ->
     wfkind sgn5 ctx5 kind_type
 | k_pi_intro : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty) (K5:K),
     wfkind sgn5  (cons ( x , A )  ctx5 )  K5 ->
     wfkind sgn5 ctx5 (kind_pi_intro x A K5)
with wftype : sgn -> ctx -> Ty -> K -> Prop :=    (* defn wftype *)
 | ty_tcon : forall (sgn5:sgn) (ctx5:ctx) (alpha:tcon) (K5:K),
     wfctx sgn5 ctx5 ->
      (boundTCon  alpha   K5   sgn5 )  ->
     wftype sgn5 ctx5 (type_tcon alpha) K5
 | ty_pi_intro : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A B:Ty),
     wftype sgn5  (cons ( x , A )  ctx5 )  B kind_type ->
     wftype sgn5 ctx5 (type_pi_intro x A B) kind_type
 | ty_pi_elim : forall (sgn5:sgn) (ctx5:ctx) (A:Ty) (M:te) (K5:K) (x:var) (B:Ty),
     wftype sgn5 ctx5 A (kind_pi_intro x B K5) ->
     wfterm sgn5 ctx5 M B ->
     wftype sgn5 ctx5 (type_pi_elim A M)  (subst_K  M   x   K5 ) 
with wfterm : sgn -> ctx -> te -> Ty -> Prop :=    (* defn wfterm *)
 | te_con : forall (sgn5:sgn) (ctx5:ctx) (c:con) (A:Ty),
     wfctx sgn5 ctx5 ->
      (boundCon  c   A   sgn5 )  ->
     wfterm sgn5 ctx5 (term_con c) A
 | te_var : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty),
     wfctx sgn5 ctx5 ->
      (boundVar  x   A   ctx5 )  ->
     wfterm sgn5 ctx5 (term_var x) A
 | te_pi_intro : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty) (M:te) (B:Ty),
     wfterm sgn5  (cons ( x , A )  ctx5 )  M B ->
     wfterm sgn5 ctx5 (term_pi_intro x A M) (type_pi_intro x A B)
 | te_pi_elim : forall (sgn5:sgn) (ctx5:ctx) (M N:te) (B:Ty) (x:var) (A:Ty),
     wfterm sgn5 ctx5 M (type_pi_intro x A B) ->
     wfterm sgn5 ctx5 N A ->
     wfterm sgn5 ctx5 (term_pi_elim M N)  ( subst_Ty  N   x   B  ) 
 | te_conv : forall (sgn5:sgn) (ctx5:ctx) (M:te) (A' A:Ty),
     wfterm sgn5 ctx5 M A ->
     wftype sgn5 ctx5 A' kind_type ->
     substaptype sgn5 ctx5 A A' ->
     wfterm sgn5 ctx5 M A'
with substapkind : sgn -> ctx -> K -> K -> Prop :=    (* defn substapkind *)
 | eqK_refl : forall (sgn5:sgn) (ctx5:ctx) (K5:K),
     substapkind sgn5 ctx5 K5 K5
 | eqK_sym : forall (sgn5:sgn) (ctx5:ctx) (K5 K':K),
     substapkind sgn5 ctx5 K' K5 ->
     substapkind sgn5 ctx5 K5 K'
 | eqK_trans : forall (sgn5:sgn) (ctx5:ctx) (K_1 K_3 K_2:K),
     substapkind sgn5 ctx5 K_1 K_2 ->
     substapkind sgn5 ctx5 K_2 K_3 ->
     substapkind sgn5 ctx5 K_1 K_3
 | eqK_1 : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty) (K5:K) (A':Ty) (K':K),
     substaptype sgn5 ctx5 A A' ->
     substapkind sgn5 ctx5 K5 K' ->
     substapkind sgn5 ctx5 (kind_pi_intro x A K5) (kind_pi_intro x A' K')
with substaptype : sgn -> ctx -> Ty -> Ty -> Prop :=    (* defn substaptype *)
 | eqT_refl : forall (sgn5:sgn) (ctx5:ctx) (A:Ty),
     substaptype sgn5 ctx5 A A
 | eqT_sym : forall (sgn5:sgn) (ctx5:ctx) (A A':Ty),
     substaptype sgn5 ctx5 A' A ->
     substaptype sgn5 ctx5 A A'
 | eqT_trans : forall (sgn5:sgn) (ctx5:ctx) (A_1 A_3 A_2:Ty),
     substaptype sgn5 ctx5 A_1 A_2 ->
     substaptype sgn5 ctx5 A_2 A_3 ->
     substaptype sgn5 ctx5 A_1 A_3
 | eqT_1 : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A B A' B':Ty),
     substaptype sgn5 ctx5 A A' ->
     substaptype sgn5 ctx5 B B' ->
     substaptype sgn5 ctx5 (type_pi_intro x A B) (type_pi_intro x A' B')
 | eqT_2 : forall (sgn5:sgn) (ctx5:ctx) (A:Ty) (M:te) (A':Ty) (M':te),
     substaptype sgn5 ctx5 A A' ->
     substapterm sgn5 ctx5 M M' ->
     substaptype sgn5 ctx5 (type_pi_elim A M) (type_pi_elim A' M')
with substapterm : sgn -> ctx -> te -> te -> Prop :=    (* defn substapterm *)
 | eqt_refl : forall (sgn5:sgn) (ctx5:ctx) (M:te),
     substapterm sgn5 ctx5 M M
 | eqt_sym : forall (sgn5:sgn) (ctx5:ctx) (M M':te),
     substapterm sgn5 ctx5 M' M ->
     substapterm sgn5 ctx5 M M'
 | eqt_trans : forall (sgn5:sgn) (ctx5:ctx) (M_1 M_3 M_2:te),
     substapterm sgn5 ctx5 M_1 M_2 ->
     substapterm sgn5 ctx5 M_2 M_3 ->
     substapterm sgn5 ctx5 M_1 M_3
 | eqt_1 : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty) (M N M' N':te),
     substapterm sgn5 ctx5 M M' ->
     substapterm sgn5 ctx5 N N' ->
     substapterm sgn5 ctx5 (term_pi_elim  (term_pi_intro x A M)  N)  ( subst_te  N'   x   M'  ) 
 | eqt_2 : forall (sgn5:sgn) (ctx5:ctx) (M N M' N':te),
     substapterm sgn5 ctx5 M M' ->
     substapterm sgn5 ctx5 N N' ->
     substapterm sgn5 ctx5 (term_pi_elim M N) (term_pi_elim M' N')
 | eqt_3 : forall (sgn5:sgn) (ctx5:ctx) (x:var) (A:Ty) (M:te) (A':Ty) (M':te),
     substaptype sgn5 ctx5 A A' ->
     substapterm sgn5 ctx5 M M' ->
     substapterm sgn5 ctx5 (term_pi_intro x A M) (term_pi_intro x A' M').
Notation nsigempty := (@nil (con*nTy+tcon*nK)).
Notation nctxempty := (@nil (nTy)).

Definition fstnSig (e : (con*nTy)+(tcon*nK) ) := match e with
    | inl (c, nty) => inl c
    | inr (beta, nk) => inr beta
  end.


Definition boundnCon c T0 S :=
  exists S1, exists S2,
    (S = List.app S1 (List.cons (inl(c,T0)) S2)) /\
    ~In (inl(c)) (List.map (fstnSig) S1).

Definition boundnTCon alpha T0 S :=
  exists S1, exists S2,
    (S = List.app S1 (List.cons (inr(alpha,T0)) S2)) /\
    ~In (inr(alpha)) (List.map (fstnSig) S1).

(*
Definition boundVar x T0 G :=
  exists G1, exists G2,
    (G = List.app G1 (List.cons (x,T0) G2)) /\
    ~In x (List.map (@fst var Ty) G1).
*)

Definition indomnCon c S :=
  exists C,
    boundnCon c C S.

Definition indomnTCon alpha S :=
  exists K,
    boundnTCon alpha K S.

(*
Definition indomVar x S :=
  exists T0,
    boundVar x T0 S.
*)


(** definitions *)

(** funs PincteTy *)
Fixpoint pincte (x1:nte) : nte:=
  match x1 with
  | (term_nl_cdb cdb_zero) => (term_nl_pdb pdb_zero)
  | (term_nl_cdb (cdb_succ ic)) => (term_nl_cdb ic)
  | (term_nl_pdb ip) => (term_nl_pdb (pdb_succ ip))
  | (term_nl_con c) => (term_nl_con c)
  | (term_nl_pi_intro C P) => (term_nl_pi_intro  (pincTy C )   (pincte P ) )
  | (term_nl_pi_elim Q P) => (term_nl_pi_elim   (pincte Q )     (pincte P )  )
end
with pincTy (x1:nTy) : nTy:=
  match x1 with
  | (type_nl_tcon alpha) => (type_nl_tcon alpha)
  | (type_nl_pi_elim C P) => (type_nl_pi_elim   (pincTy C )     (pincte P )  )
  | (type_nl_pi_intro C D) => (type_nl_pi_intro  (pincTy C )   (pincTy D ) )
end.

(** definitions *)

(** funs PincK *)
Fixpoint pincK (x1:nK) : nK:=
  match x1 with
  | kind_nl_type => kind_nl_type
  | (kind_nl_pi_intro C nK5) => (kind_nl_pi_intro  (pincTy C )   (pincK nK5 ) )
end.

(** definitions *)

(** funs PdecteTy *)
Fixpoint pdecte (x1:nte) : nte:=
  match x1 with
  | (term_nl_cdb ic) => (term_nl_cdb (cdb_succ ic))
  | (term_nl_pdb pdb_zero) => (term_nl_cdb cdb_zero)
  | (term_nl_pdb (pdb_succ ip)) => (term_nl_pdb ip)
  | (term_nl_con c) => (term_nl_con c)
  | (term_nl_pi_intro C P) => (term_nl_pi_intro  (pdecTy C )   (pdecte P ) )
  | (term_nl_pi_elim Q P) => (term_nl_pi_elim   (pdecte Q )     (pdecte P )  )
end
with pdecTy (x1:nTy) : nTy:=
  match x1 with
  | (type_nl_tcon alpha) => (type_nl_tcon alpha)
  | (type_nl_pi_elim C P) => (type_nl_pi_elim   (pdecTy C )     (pdecte P )  )
  | (type_nl_pi_intro C D) => (type_nl_pi_intro  (pdecTy C )   (pdecTy D ) )
end.


    
(** definitions *)

(** funs PdecK *)
Fixpoint pdecK (x1:nK) : nK:=
  match x1 with
  | kind_nl_type => kind_nl_type
  | (kind_nl_pi_intro C nK5) => (kind_nl_pi_intro  (pdecTy C )   (pdecK nK5 ) )
end.

(** definitions *)

(** funs Psubst *)
Fixpoint psubste (x1:nte) (x2:nte) : nte:=
  match x1,x2 with
  | (term_nl_cdb ic) , Q => (term_nl_cdb ic)
  | (term_nl_pdb pdb_zero) , Q => Q
  | (term_nl_pdb (pdb_succ ip)) , Q => (term_nl_pdb ip)
  | (term_nl_con c) , Q => (term_nl_con c)
  | (term_nl_pi_intro C P) , Q => (term_nl_pi_intro  (psubsTy C Q )   (psubste P Q ) )
  | (term_nl_pi_elim P1 P2) , Q => (term_nl_pi_elim   (psubste P1 Q )     (psubste P2 Q )  )
end
with psubsTy (x1:nTy) (x2:nte) : nTy:=
  match x1,x2 with
  | (type_nl_tcon alpha) , Q => (type_nl_tcon alpha)
  | (type_nl_pi_elim C P) , Q => (type_nl_pi_elim   (psubsTy C Q )     (psubste P Q )  )
  | (type_nl_pi_intro C D) , Q => (type_nl_pi_intro  (psubsTy C Q )   (psubsTy D Q ) )
end.

(** definitions *)

(** funs PsubsK *)
Fixpoint psubsK (x1:nK) (x2:nte) : nK:=
  match x1,x2 with
  | kind_nl_type , Q => kind_nl_type
  | (kind_nl_pi_intro C nK5) , Q => (kind_nl_pi_intro  (psubsTy C Q )   (psubsK nK5 Q ) )
end.

(** definitions *)

(* defns Jwfnl *)
Inductive wfsig_nl : nsgn -> Prop :=    (* defn wfsig_nl *)
 | sig_nl_empty : 
     wfsig_nl  nsigempty 
 | sig_nl_tcon : forall (nsgn5:nsgn) (alpha:tcon) (nK5:nK),
     wfsig_nl nsgn5 ->
     wfkind_nl nsgn5  nctxempty  nK5 ->
      (not (indomnTCon  alpha   nsgn5 ))  ->
     wfsig_nl  (cons (inr( alpha , nK5 ))  nsgn5 ) 
 | sig_nl_con : forall (nsgn5:nsgn) (c:con) (C:nTy),
     wfsig_nl nsgn5 ->
     wftype_nl nsgn5  nctxempty  C kind_nl_type ->
      (not (indomnCon  c   nsgn5 ))  ->
     wfsig_nl  (cons (inl( c , C ))  nsgn5 ) 
with wfctx_nl : nsgn -> nctx -> Prop :=    (* defn wfctx_nl *)
 | ctx_nl_empty : forall (nsgn5:nsgn),
     wfsig_nl nsgn5 ->
     wfctx_nl nsgn5  nctxempty 
 | ctx_nl_var : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy),
     wfctx_nl nsgn5 nctx5 ->
     wftype_nl nsgn5 nctx5 C kind_nl_type ->
     wfctx_nl nsgn5  (cons  C   nctx5 ) 
with wfkind_nl : nsgn -> nctx -> nK -> Prop :=    (* defn wfkind_nl *)
 | k_nl_type : forall (nsgn5:nsgn) (nctx5:nctx),
     wfctx_nl nsgn5 nctx5 ->
     wfkind_nl nsgn5 nctx5 kind_nl_type
 | k_nl_pi_intro : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (nK5:nK),
     wfkind_nl nsgn5  (cons  C   nctx5 )  nK5 ->
     wfkind_nl nsgn5 nctx5 (kind_nl_pi_intro C nK5)
with wftype_nl : nsgn -> nctx -> nTy -> nK -> Prop :=    (* defn wftype_nl *)
 | ty_nl_tcon : forall (nsgn5:nsgn) (nctx5:nctx) (alpha:tcon) (nK5:nK),
     wfctx_nl nsgn5 nctx5 ->
      (boundnTCon  alpha   nK5   nsgn5 )  ->
     wftype_nl nsgn5 nctx5 (type_nl_tcon alpha) nK5
 | ty_nl_pi_intro : forall (nsgn5:nsgn) (nctx5:nctx) (C D:nTy),
     wftype_nl nsgn5  (cons  C   nctx5 )  D kind_nl_type ->
     wftype_nl nsgn5 nctx5 (type_nl_pi_intro C D) kind_nl_type
 | ty_nl_pi_elim : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (Q:nte) (nK5:nK) (D:nTy),
     wftype_nl nsgn5 nctx5 C (kind_nl_pi_intro D nK5) ->
     wfterm_nl nsgn5 nctx5 Q D ->
     wftype_nl nsgn5 nctx5 (type_nl_pi_elim C Q)  (psubsK nK5 Q ) 
with wfterm_nl : nsgn -> nctx -> nte -> nTy -> Prop :=    (* defn wfterm_nl *)
 | te_nl_con : forall (nsgn5:nsgn) (nctx5:nctx) (c:con) (C:nTy),
     wfctx_nl nsgn5 nctx5 ->
      (boundnCon  c   C   nsgn5 )  ->
     wfterm_nl nsgn5 nctx5 (term_nl_con c) C
 | te_nl_var_z : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy),
     wfctx_nl nsgn5  (cons  C   nctx5 )  ->
     wfterm_nl nsgn5 nctx5 (term_nl_cdb cdb_zero) C
 | te_nl_var : forall (nsgn5:nsgn) (nctx5:nctx) (ic:cdb) (D C:nTy),
     wfctx_nl nsgn5  (cons  C   nctx5 )  ->
     wfterm_nl nsgn5 nctx5 (term_nl_cdb ic) D ->
     wfterm_nl nsgn5 nctx5 (term_nl_cdb (cdb_succ ic)) D
 | te_nl_pi_intro : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (Q:nte) (D:nTy),
     wfterm_nl nsgn5  (cons  C   nctx5 )  Q D ->
     wfterm_nl nsgn5 nctx5 (term_nl_pi_intro C  (pincte Q ) ) (type_nl_pi_intro C  (pincTy D ) )
 | te_nl_pi_elim : forall (nsgn5:nsgn) (nctx5:nctx) (Q P:nte) (D C:nTy),
     wfterm_nl nsgn5 nctx5 Q (type_nl_pi_intro C D) ->
     wfterm_nl nsgn5 nctx5 P C ->
     wfterm_nl nsgn5 nctx5 (term_nl_pi_elim Q P)  (psubsTy D P ) 
 | te_nl_conv : forall (nsgn5:nsgn) (nctx5:nctx) (Q:nte) (C' C:nTy),
     wfterm_nl nsgn5 nctx5 Q C ->
     wftype_nl nsgn5 nctx5 C' kind_nl_type ->
     substaptype_nl nsgn5 nctx5 C C' kind_nl_type ->
     wfterm_nl nsgn5 nctx5 Q C'
with substaptype_nl : nsgn -> nctx -> nTy -> nTy -> nK -> Prop :=    (* defn substaptype_nl *)
 | eqT_nl_refl : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (nK5:nK),
     wftype_nl nsgn5 nctx5 C nK5 ->
     substaptype_nl nsgn5 nctx5 C C nK5
 | eqT_nl_sym : forall (nsgn5:nsgn) (nctx5:nctx) (C C':nTy) (nK5:nK),
     substaptype_nl nsgn5 nctx5 C' C nK5 ->
     substaptype_nl nsgn5 nctx5 C C' nK5
 | eqT_nl_trans : forall (nsgn5:nsgn) (nctx5:nctx) (C_1 C_3:nTy) (nK5:nK) (C_2:nTy),
     substaptype_nl nsgn5 nctx5 C_1 C_2 nK5 ->
     substaptype_nl nsgn5 nctx5 C_2 C_3 nK5 ->
     substaptype_nl nsgn5 nctx5 C_1 C_3 nK5
 | eqT_nl_1 : forall (nsgn5:nsgn) (nctx5:nctx) (C D C' D':nTy),
     substaptype_nl nsgn5 nctx5 C C' kind_nl_type ->
     substaptype_nl nsgn5 nctx5 D D' kind_nl_type ->
     substaptype_nl nsgn5 nctx5 (type_nl_pi_intro C D) (type_nl_pi_intro C' D') kind_nl_type
 | eqT_nl_2 : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (Q:nte) (C':nTy) (Q':nte),
     substaptype_nl nsgn5 nctx5 C C' kind_nl_type ->
     substapterm_nl_ nsgn5 nctx5 Q Q' C ->
     substaptype_nl nsgn5 nctx5 (type_nl_pi_elim C Q) (type_nl_pi_elim C' Q') kind_nl_type
with substapterm_nl_ : nsgn -> nctx -> nte -> nte -> nTy -> Prop :=    (* defn substapterm_nl_ *)
 | eqt_nl_refl : forall (nsgn5:nsgn) (nctx5:nctx) (Q:nte) (C:nTy),
     wfterm_nl nsgn5 nctx5 Q C ->
     substapterm_nl_ nsgn5 nctx5 Q Q C
 | eqt_nl_sym : forall (nsgn5:nsgn) (nctx5:nctx) (Q Q':nte) (C:nTy),
     substapterm_nl_ nsgn5 nctx5 Q' Q C ->
     substapterm_nl_ nsgn5 nctx5 Q Q' C
 | eqt_nl_trans : forall (nsgn5:nsgn) (nctx5:nctx) (Q_1 Q_3:nte) (C:nTy) (Q_2:nte),
     substapterm_nl_ nsgn5 nctx5 Q_1 Q_2 C ->
     substapterm_nl_ nsgn5 nctx5 Q_2 Q_3 C ->
     substapterm_nl_ nsgn5 nctx5 Q_1 Q_3 C
 | eqt_nl_1 : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (Q P Q' P':nte) (D:nTy),
     substapterm_nl_ nsgn5 nctx5 Q Q' C ->
     substapterm_nl_ nsgn5 nctx5 P P' D ->
     substapterm_nl_ nsgn5 nctx5 (term_nl_pi_elim  (term_nl_pi_intro C Q)  P)  (psubste Q' P' )   (psubsTy C P' ) 
 | eqt_nl_2 : forall (nsgn5:nsgn) (nctx5:nctx) (Q P Q' P':nte) (C D:nTy),
     substapterm_nl_ nsgn5 nctx5 Q Q' (type_nl_pi_intro C D) ->
     substapterm_nl_ nsgn5 nctx5 P P' C ->
     substapterm_nl_ nsgn5 nctx5 (term_nl_pi_elim Q P) (term_nl_pi_elim Q' P')  (psubsTy C P ) 
 | eqt_nl_3 : forall (nsgn5:nsgn) (nctx5:nctx) (C:nTy) (Q:nte) (C':nTy) (Q':nte) (D:nTy),
     substaptype_nl nsgn5 nctx5 C C' kind_nl_type ->
     substapterm_nl_ nsgn5 nctx5 Q Q' D ->
     substapterm_nl_ nsgn5 nctx5 (term_nl_pi_intro C Q) (term_nl_pi_intro C' Q') (type_nl_pi_intro C D).

(* depth of term/type  *)
(** funs PincteTy *)
Fixpoint depthte (x1:nte) : nat:=
  match x1 with
  | (term_nl_cdb cdb_zero) => O
  | (term_nl_cdb (cdb_succ ic)) => O
  | (term_nl_pdb ip) => O
  | (term_nl_con c) => O
  | (term_nl_pi_intro C P) => S (max (depthTy C ) (depthte P ) )
  | (term_nl_pi_elim Q P) => S (max  (depthte Q )     (depthte P ) )
end
with depthTy (x1:nTy) : nat:=
  match x1 with
  | (type_nl_tcon alpha) => 0
  | (type_nl_pi_elim C P) => S (max   (depthTy C )     (depthte P )  )
  | (type_nl_pi_intro C D) => S (max (depthTy C )   (depthTy D ) )
end.

(* metatheorems *)

Lemma wfsig_nl_strenghtening_l :
  forall (S : nsgn) (c : con) (C : nTy),
    wfsig_nl ( (inl (c , C)) :: S) -> wfsig_nl S.
Proof.
  intros; inversion H; assumption.
Qed.

Lemma wfsig_nl_strenghtening_r :
  forall (S : nsgn) (alpha : tcon) (K : nK),
    wfsig_nl ( (inr (alpha , K)) :: S) -> wfsig_nl S.
Proof.
  intros; inversion H; assumption.
Qed.

Lemma wfctx_nl_strenghtening :
  forall (S : nsgn) (G : nctx) (C : nTy) ,
    wfctx_nl S (C :: G) -> wfctx_nl S G /\ wftype_nl S G C kind_nl_type.
Proof.
  intros; inversion H.
  split; assumption; assumption.  
Qed.

Lemma boundnTCon_weakening_l:
  forall (S S1 : nsgn) (alpha : tcon) (K: nK),
    boundnTCon alpha K S ->
    boundnTCon alpha K (S ++ S1).
Proof.
  intros.
  unfold boundnTCon.
  unfold boundnTCon in H.
  decompose record H.
  apply ex_intro with x.
  apply ex_intro with (x0 ++ S1).
  split.
  rewrite H0.
  symmetry.
  apply app_assoc with (l := x) (m := (inr (alpha, K0) :: x0)) (n := S1).
  assumption.
Qed.
 
Lemma boundnTCon_strenghtening_l:
  forall (S S1 : nsgn) (alpha : tcon) (K: nK),
    ~ boundnTCon alpha K (S ++ S1) ->
    ~ boundnTCon alpha K S.
Proof.    
  intros.
  intro.
  apply boundnTCon_weakening_l with S S1 alpha K0 in H0.
  contradiction.
Qed.  

Lemma indomTCon_weakening_l:
  forall (S S1 : nsgn) (alpha : tcon),
    indomnTCon alpha S ->
    indomnTCon alpha (S ++ S1) .
Proof.
  intros.
  unfold indomnTCon in H.
  decompose record H.
  apply ex_intro with x.
  apply boundnTCon_weakening_l.
  assumption.
Qed.

Lemma indomTCon_strenghtening_l:
  forall (S S1 : nsgn) (alpha : tcon),
    ~ indomnTCon alpha (S ++ S1) ->
    ~ indomnTCon alpha S.
Proof.    
  intros.
  intro.
  apply indomTCon_weakening_l with (S1 := S1) in H0.
  contradiction.
Qed.
  
Lemma boundnTCon_weakening_r:
  forall (S S1 : nsgn) (alpha beta: tcon) (K L: nK),
    wfsig_nl (inr(alpha,K) :: S) ->
    boundnTCon beta L S ->
    boundnTCon beta L (inr(alpha,K) :: S).
Proof.
  intros.
  inversion H0.
  decompose record H1.
  apply ex_intro with (inr(alpha,K0)::x).
  apply ex_intro with x0.
  split.
  rewrite H3.
  apply app_comm_cons.
  intro.
  inversion H.
  rewrite H3 in H10.
  inversion H2.
  replace (fstnSig (inr (alpha, K0))) with (@inr con tcon alpha) in H11 by (cbv; auto).
  inversion H11.
  rewrite H13 in H10.
  destruct H10.
  apply ex_intro with L.
  apply ex_intro with x.
  apply ex_intro with x0.
  split.
  reflexivity.
  assumption.
  contradiction.
Qed.

Lemma indom_strenghtening_r:
  forall (S S1 : nsgn) (alpha : tcon),
    ~ indomnTCon alpha (S ++ S1) ->
    ~ indomnTCon alpha S1.
Proof.    
  intros.
  
  unfold indomnTCon in H.
  unfold indomnTCon.
  unfold boundnTCon in H.
  unfold boundnTCon.
  intro.
  destruct H0; destruct H0; destruct H0; destruct H0.
  destruct H.
  apply ex_intro with x.
  apply ex_intro with (S ++ x0).
  apply ex_intro with (x1).
  split.
  rewrite H0.
  
  admit.
Admitted.

Lemma boundnTCon_weakening_l'' :
  forall (S : nsgn) (alpha beta : tcon) (K L : nK),
    boundnTCon beta L S ->
    wfsig_nl (inr (alpha, K) :: S) ->
    boundnTCon beta L (inr (alpha, K) :: S).
Proof.
  intros.
  destruct H.
  destruct H.
  destruct H.
  rewrite H.
  unfold boundnTCon.
  apply ex_intro with (inr(alpha,K0) :: x). 
  exists (x0).
  split.
  apply app_comm_cons.
  rewrite H in H0.
  clear H. clear S.
  inversion H0.
  intro.
  inversion H7.
  replace (fstnSig (inr (alpha, K0))) with (@inr con tcon alpha) in H8
    by (cbv; reflexivity).
  inversion H8.
  rewrite H10 in H6.
  destruct H6.
  unfold indomnTCon. unfold boundnTCon.
  apply ex_intro with L.
  apply ex_intro with x.
  apply ex_intro with x0.
  split.
  reflexivity.
  assumption.
  contradiction.
Qed.

Lemma boundnCon_strenghtening_l :
  forall (S : nsgn) (beta : tcon) (c : con) (C D : nTy),
    boundnCon beta C (inl (c, D) :: S) ->
    boundnCon beta C S.
Proof.
(*  intros.
  unfold boundnCon in H.
  unfold boundnCon.
  decompose record H.
  destruct x.
  inversion H0.
  inversion H0.
  apply ex_intro with (x).
  apply ex_intro with (x0).
  split.
  reflexivity.
  rewrite <- H3 in H2.
  intro.
  replace (map fstnSig (inr (alpha, K0) :: x))
  with ((inr alpha) :: (map fstnSig x))
    in H2 by (auto).
  destruct H2.
  apply in_cons.
  assumption.
Qed.
*)

Lemma boundnCon_strenghtening_r :
  forall (S : nsgn) (alpha beta : tcon) (K : nK) (C : nTy),
    boundnCon beta C (inr (alpha, K) :: S) ->
    boundnCon beta C S.
Proof.
  intros.
  unfold boundnCon in H.
  unfold boundnCon.
  decompose record H.
  destruct x.
  inversion H0.
  inversion H0.
  apply ex_intro with (x).
  apply ex_intro with (x0).
  split.
  reflexivity.
  rewrite <- H3 in H2.
  intro.
  replace (map fstnSig (inr (alpha, K0) :: x))
  with ((inr alpha) :: (map fstnSig x))
    in H2 by (auto).
  destruct H2.
  apply in_cons.
  assumption.
Qed.

Lemma boundnCon_weakening_l :
  forall (S : nsgn) (beta : tcon) (c : con) (C D : nTy),
    boundnCon beta C S ->
    wfsig_nl (inl (c, D) :: S) ->
    boundnCon beta C (inl (c, D) :: S).
Proof.
  admit.
Admitted.


Lemma boundnCon_weakening_r :
  forall (S : nsgn) (alpha beta : tcon) (K : nK) (C : nTy),
    boundnCon beta C S ->
    wfsig_nl (inr (alpha, K) :: S) ->
    boundnCon beta C (inr (alpha, K) :: S).
Proof.
  admit.
Admitted.


Lemma wfctx_nl_wfsub:
  forall ( S : nsgn ) ( G : nctx ),
    wfctx_nl S G ->
    wfsig_nl S.
Proof.
  intros.
  induction G. 
  inversion H.
  assumption.
  apply wfctx_nl_strenghtening in H.
  destruct H.
  exact (IHG H).
Qed.

Lemma wftype_nl_wfsub:
  forall ( S : nsgn ) ( G : nctx ) ( C : nTy) (K : nK),
    wftype_nl S G C K ->
    wfsig_nl S /\ wfctx_nl S G .
Proof.
  intros.
  generalize dependent K0.
  generalize G.
  induction C.
  (* base case *)
  intros.
  inversion H.
  split.
  apply wfctx_nl_wfsub in H1.
  assumption.
  assumption.
  (* induction - pi_elim *)
  intros.
  inversion H.
  apply IHC in H4.
  assumption.
  (* induction - pi_intro *)
  intros.
  inversion H.
  apply IHC2 in H5; decompose [ and ] H5.
  split.
  assumption.
  inversion H7.
  assumption.
Qed.

Lemma wfterm_nl_wfsub:
  forall ( S : nsgn ) ( G : nctx ) ( C : nTy) (P : nte),
    wfterm_nl S G P C ->
    wfsig_nl S /\ wfctx_nl S G.  
Proof.
  admit.
Admitted.

(*  
Lemma wfsig_tcon :
  forall (S : nsgn) (G : nctx) (alpha : tcon) (L : nK),
    wfsig_nl S -> boundnTCon alpha L S -> wfkind_nl S G L.
Proof.
*)


Lemma wfctx_nl_weakening_sgn_l:
  forall (S : nsgn) (G : nctx) (c : con) (C : nTy),
    wfctx_nl S G ->
    wfsig_nl ( (inl (c, C)) :: S) ->
    wfctx_nl ( (inl (c, C)) :: S) G
with wftype_nl_weakening_sgn_l:
  forall (S : nsgn) (G : nctx) (c : con) (L : nK) (C D : nTy),
    wftype_nl S G C L ->
    wfsig_nl (inl (c, D) :: S) ->
    wftype_nl (inl (c, D) :: S) G C L
with wfterm_nl_weakening_sgn_l:
  forall (S : nsgn) (G : nctx) (c : con) (K : nK) (C D : nTy) (P : nte),
    wfterm_nl S G P C ->
    wfsig_nl (inl (c, D) :: S) ->
    wfterm_nl (inl (c, D) :: S) G P C
.
Proof.
  admit.
  admit.
  admit.
Admitted.

Lemma wfctx_nl_weakening_sgn_r:
  forall (S : nsgn) (G : nctx) (alpha : tcon) (K : nK),
    wfctx_nl S G ->
    wfsig_nl ( (inr (alpha, K)) :: S) ->
    wfctx_nl ( (inr (alpha, K)) :: S) G
with wftype_nl_weakening_sgn_r:
  forall (S : nsgn) (G : nctx) (alpha : tcon) (K L : nK) (C : nTy),
    wftype_nl S G C L ->
    wfsig_nl (inr (alpha, K) :: S) ->
    wftype_nl (inr (alpha, K) :: S) G C L
with wfterm_nl_weakening_sgn_r:
  forall (S : nsgn) (G : nctx) (alpha : tcon) (K : nK) (C : nTy) (P : nte),
    wfterm_nl S G P C ->
    wfsig_nl (inr (alpha, K) :: S) ->
    wfterm_nl (inr (alpha, K) :: S) G P C
.
Proof.
  (* lem 1 *)
  intros.
  induction G.
  apply ctx_nl_empty.
  assumption.
  apply wfctx_nl_strenghtening in H.
  destruct H.
  apply ctx_nl_var.
  apply IHG in H.
  assumption.
  apply wftype_nl_weakening_sgn_r.
  assumption.
  assumption.
  (* lem 2 *)
  intros.
  induction C.
  inversion H.
  apply ty_nl_tcon.
  apply wfctx_nl_weakening_sgn_r.  
  assumption.
  assumption.  
  apply boundnTCon_weakening_r.
  assumption.
  assumption.
  inversion H.
  assumption.
  (* case ty_nl_pi_elim *)
  inversion H.  
  apply ty_nl_pi_elim with D. 
  apply wftype_nl_weakening_sgn_r.
  assumption.
  assumption.
  apply wfterm_nl_weakening_sgn_r.
  assumption.
  assumption.
  (* case ty_nl_pi_intro *)
  inversion H.
  apply ty_nl_pi_intro.
  apply wftype_nl_weakening_sgn_r.
  assumption.
  assumption.
  (* lem 3 *)
  intros.
  induction (P).
  induction (C).
  (* case te_nl_cdb *)  
  induction cdb5.
  apply te_nl_var_z.
  apply ctx_nl_var.  
  apply wfctx_nl_weakening_sgn_r.
  apply wfterm_nl_wfsub in H.
  decompose [and] H.
  assumption.
  assumption.
  inversion H.
  inversion H1.
  apply wftype_nl_weakening_sgn_r.
  assumption.
  assumption.
  apply wftype_nl_weakening_sgn_r.
  assumption.
  assumption.
  inversion H.
  apply IHcdb5 in H5.
  apply te_nl_var.

    
  destruct C.
  eapply te_nl_var. 
  apply wfctx_nl_weakening_sgn_r.
  apply ctx_nl_var.
  apply wfterm_nl_wfsub in H.
  decompose record H.
  assumption.
  inversion H.
  inversion H2.
  assumption.
  apply IHcdb5 in H.
  
  admit. (* project wftype_nl from wfterm *)
  assumption.
  apply wfterm_nl_weakening_sgn_r.
  assumption.
  assumption.
  apply wfterm_nl_weakening_sgn_r.
  assumption.
  assumption.
  apply wfterm_nl_weakening_sgn_r.
  assumption.
  assumption.
  apply wfterm_nl_weakening_sgn_r.
  assumption.
  assumption.
  apply wfterm_nl_weakening_sgn_r.
  assumption.
  assumption.
Admitted.
  

Lemma wfkind_nl_weakening_sgn_r :
  forall (S : nsgn) (G : nctx) (alpha : tcon) (K L : nK),
    wfkind_nl S G L ->
    wfsig_nl ( (inr (alpha, K)) :: S) ->
    wfkind_nl ( (inr (alpha, K)) :: S) G L
.
Proof.
  intros.
  generalize dependent G.
  induction L.
  intros.
  apply k_nl_type.  
  apply wfctx_nl_weakening_sgn_r.
  inversion H.
  assumption.
  assumption.
  intros.
  apply k_nl_pi_intro.
  inversion H.
  apply IHL in H4.
  assumption.
Qed.

Lemma wfkind_nl_weakening_ctx_r :
  forall (S : nsgn) (G : nctx) (C : nTy) (L : nK),
    wfkind_nl S G L ->
    wfctx_nl S (C :: G) ->
    wfkind_nl S (C :: G) (pdecK L).
Proof.
  intros.
  generalize dependent G.
  induction L.
  (* case kind_nl_type *)
  intros.
  apply k_nl_type.
  assumption.
  (* case kind_nl_pi_intro *)
  intros.
  inversion H.

  
Lemma wfsig_con :
  forall (S : nsgn) (c : con) (C : nTy),
    wfsig_nl S -> boundnCon c C S -> exists K , wftype_nl S nctxempty C K.

Lemma wfctx_type :
  forall (S : nsgn) (G : nctx) (C : nTy) ,
    wfctx_nl S (C :: G) -> wftype_nl S G C kind_nl_type.
Proof.
  intros.
  inversion H.
  assumption.
Qed.

Lemma wfsig_type :
  forall (S : nsgn) (G : nctx) (c : con) (C : nTy),
    wfsig_nl S ->
    boundnCon c C S ->
    wftype_nl S G C kind_nl_type.
Proof.
  intros.
  generalize G.
  induction S.
  destruct H0.
  destruct H0.
  decompose [and] H0.
  apply (app_cons_not_nil) in H1.
  contradiction.
  intro.
  destruct a.
  inversion H.
  admit.
  inversion H.
  apply IHS with G0 in H3.
  apply wftype_nl_weakening_sgn_r.
  assumption.
  rewrite H1.
  assumption.
  rewrite <- H1 in H0.
  apply boundnCon_strenghtening_r in H0.
  assumption.
Admitted.

Lemma boundnCon_type :
  forall (S : nsgn) (G : nctx) (c : con) (C : nTy) ,
    wfsig_nl S ->
    boundnCon c C S ->
    (wftype_nl S G C kind_nl_type).
Proof.
  intros.
  induction S.
  destruct H0.
  destruct H0.
  decompose [and] H0.
  inversion H.
  apply app_cons_not_nil in H1.
  contradiction.
  destruct a.
  admit.
  inversion H.
  rewrite <- H1 in H0.
  apply boundnCon_strenghtening_r in H0.
  apply IHS in H3.
  apply wftype_nl_weakening_sgn_r.
  assumption.
  rewrite <- H1 in H.
  assumption.
  assumption.
Admitted.

Lemma wfterm_type :
  forall (S : nsgn) (G : nctx) (P : nte) (C : nTy) ,
    wfterm_nl S G P C -> exists K , (wftype_nl S G C K).
Proof.
  intros.
  induction P.
  induction cdb5. 
  apply ex_intro with kind_nl_type.
  inversion H.
  inversion H0.
  assumption.
  assumption.
  inversion H.
  apply IHcdb5 in H4.
  assumption.
  apply ex_intro with kind_nl_type.
  assumption.
  (* case pdb *)
  induction pdb5.
  inversion H.
  apply ex_intro with kind_nl_type.
  assumption.
  inversion H.
  apply ex_intro with kind_nl_type.
  assumption.
  (* case con *)
  inversion H.
  apply wfctx_nl_wfsub in H1.
  apply boundnCon_type with (G := G) (c := con5) (C := C) in H1.
  apply ex_intro with kind_nl_type.
  assumption.
  assumption.
  apply ex_intro with kind_nl_type.
  assumption.
  (* case term_pi_intro *)
  admit.
  (* case term_pi_elim *)
  admit.
Admitted.

Theorem id_incdecte :
  forall (S : nsgn) (G : nctx) (P : nte) (C : nTy) ,
    wfterm_nl S G P C -> pincte (pdecte P) = P
with id_incdecty :
  forall (S : nsgn) (G : nctx) (C : nTy) (K : nK),
    wftype_nl S G C K -> pincTy (pdecTy C) = C.
Proof.
  (* in_incdecte *)
  intros.
  induction P.
  replace (pdecte (term_nl_cdb cdb5)) with (term_nl_cdb (cdb_succ cdb5)) by (cbv; reflexivity).
  replace (pincte (term_nl_cdb (cdb_succ cdb5))) with (term_nl_cdb cdb5) by (cbv; reflexivity).
  reflexivity.
  case pdb5.
  replace (pdecte (term_nl_pdb (pdb_zero))) with (term_nl_cdb cdb_zero)
    by (cbv;reflexivity).
  replace (pincte (term_nl_cdb cdb_zero)) with (term_nl_pdb pdb_zero)
    by (cbv; reflexivity).
  reflexivity.
  intro.
  replace (pdecte (term_nl_pdb (pdb_succ pdb0))) with (term_nl_pdb pdb0)
    by (cbv;reflexivity).
  replace (pincte (term_nl_pdb pdb0)) with (term_nl_pdb (pdb_succ pdb0))
    by (cbv; reflexivity).
  reflexivity.
  replace (pdecte (term_nl_con con5)) with (term_nl_con con5) by (cbv; reflexivity).
  replace (pincte (term_nl_con con5)) with (term_nl_con con5) by (cbv; reflexivity).
  reflexivity.
  replace (pdecte (term_nl_pi_intro nTy5 P))
  with (term_nl_pi_intro (pdecTy nTy5) (pdecte P))
    by (cbv; reflexivity).
  replace (pincte (term_nl_pi_intro (pdecTy nTy5) (pdecte P)))
  with (term_nl_pi_intro (pincTy (pdecTy nTy5)) (pincte (pdecte P)))
    by (cbv; reflexivity).
  f_equal.
  admit.
  admit.
  admit.

  (* case Ty *)
  admit.
Admitted.


           
           